/*
索引的常见模型：索引的出现是为了提高查询效率，可以用于提高读写效率的数据结构很多，分别是哈希表、有序数组和搜索树。
哈希表是一种以键-值（key-value）存储数据的结构,用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。
    不可避免地，多个key值经过哈希函数的换算，会出现同一个值的情况。用链表连接起来。
    哈希表这种结构适用于只有等值查询的场景，不适合范围查找
有序数组在等值查询和范围查询场景中的性能就都非常优秀，只适用于静态存储引擎，数据插入或删除，都很导致数据移动问题

为了维持O(log(N))的查询复杂度，需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是O(log(N))。
一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要10 ms左右的寻址时间。
对于一个100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10 ms的时间，这个查询可真够慢的。
为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。不应该使用二叉树，而是要使用“N叉”树。这里，“N叉”树中的“N”取决于数据块的大小。
以InnoDB的一个整数字段索引为例，这个N差不多是1200。这棵树高是4的时候，就可以存1200的3次方个值，这已经17亿了。
考虑到树根的数据块总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。
其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。
N叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。
InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。
 */

#主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。 NOT NULL PRIMARY KEY AUTO_INCREMENT。
create table TIndex(id int primary key,
                    k int not null,
                    name varchar(16),
                    index (k)
)engine=InnoDB;
show index from TIndex;
insert into TIndex values (100,1,'R1'),(200,2,'R2'),(300,3,'R3'),(500,5,'R4'),(600,6,'R5');
select  * from TIndex;
/*基于主键索引和普通索引的查询有什么区别？
    主键查询方式，则只需要搜索ID这棵B+树；
    即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。
    基于非主键索引的查询需要多扫描一棵索引树。因此，应该尽量使用主键查询。
 */
select * from TIndex where ID=500;
#1 row retrieved starting from 1 in 37 ms (execution: 7 ms, fetching: 30 ms)
select * from TIndex where k=5; #数据量少，不创建索引查询更快
#1 row retrieved starting from 1 in 124 ms (execution: 5 ms, fetching: 119 ms)

/*
为什么要重建索引。索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，
把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。
 */

#如果你要重建索引 k，你的两个SQL语句可以这么写：
alter table TIndex drop index k;
alter table TIndex add index(k);
#如果你要重建主键索引，也可以这么写：
alter table TIndex drop primary key;
alter table TIndex add primary key(id);
/*对于上面这两个重建索引的作法，说出你的理解。如果有不合适的，为什么，更好的方法是什么？
重建索引k的做法是合理的，可以达到省空间的目的。但是，重建主键的过程不合理。不论是删除主键还是创建主键，都会将整个表重建。
所以连着执行这两个语句的话，第一个语句就白做了。这两个语句，你可以用这个语句代替 ： alter table T engine=InnoDB。
 */
alter table TIndex engine=InnoDB;

create table Tt (
                    ID int primary key,
                    k int NOT NULL DEFAULT 0,
                    s varchar(16) NOT NULL DEFAULT '',
                    index k(k))
    engine=InnoDB;
insert into Tt values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');
explain select * from Tt where k between 3 and 5;   #需要执行几次树的搜索操作，会扫描多少行？
/*
在k索引树上找到k=3的记录，取得 ID = 300；再到ID索引树查到ID=300对应的R3；
在k索引树取下一个值k=5，取得ID=500；再回到ID索引树查到ID=500对应的R4；
在k索引树取下一个值k=6，不满足条件，循环结束。在这个过程中，回到主键索引树搜索的过程，我们称为回表。
可以看到，这个查询过程读了k索引树的3条记录（步骤1、3和5），回表了两次（步骤2和4）。
 */

CREATE TABLE `geek` (
                        `a` int(11) NOT NULL,
                        `b` int(11) NOT NULL,
                        `c` int(11) NOT NULL,
                        `d` int(11) NOT NULL,
                        PRIMARY KEY (`a`,`b`),
                        KEY `c` (`c`),
                        KEY `ca` (`c`,`a`),
                        KEY `cb` (`c`,`b`)
) ENGINE=InnoDB;
/*
公司的同事告诉他说，由于历史原因，这个表需要a、b做联合主键，这个小吕理解了。
既然主键包含了a、b这两个字段，那意味着单独在字段c上创建一个索引，就已经包含了三个字段了呀，为什么要创建“ca”“cb”这两个索引？
同事告诉他，是因为他们的业务里面有这样的两种语句：
*/
select * from geek where c=1 order by a limit 1;
select * from geek where c=2 order by b limit 1;
/*
我给你的问题是，这位同事的解释对吗，为了这两个查询模式，这两个索引是否都是必须的？为什么呢？
表记录
–a--|–b--|–c--|–d-
主键 a，b的聚簇索引组织顺序相当于 order by a,b ，也就是先按a排序，再按b排序，c无序。
索引 ca 的组织是先按c排序，再按a排序，同时记录主键
–c--|–a--|–主键部分b--
这个跟索引c的数据是一模一样的。
索引 cb 的组织是先按c排序，在按b排序，同时记录主键
–c--|–b--|–主键部分a--
所以，结论是ca可以去掉，cb需要保留。
 */

/*
对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。
对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。
对于整型字段，一个数据页可以放近千个key，因此出现这种情况的概率会很低。
计算平均性能差异时，仍可以认为这个操作成本对于现在的CPU来说可以忽略不计。

当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下
，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了。
在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。

将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。除了访问这个数据页会触发merge外，系统有后台线程会定期merge。
在数据库正常关闭（shutdown）的过程中，也会执行merge操作。

如果能够将更新操作先记录在change buffer，减少读磁盘，语句的执行速度会得到明显的提升。
而且，数据读入内存是需要占用buffer pool的，所以这种方式还能够避免占用内存，提高内存利用率。

对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。
比如，要插入(4,400)这个记录，就要先判断现在表中是否已经存在k=4的记录，而这必须要将数据页读入内存才能判断。
如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了。
因此，唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。

change buffer的大小，可以通过参数innodb_change_buffer_max_size来动态设置。
这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。
 */
show variables  like  'innodb_change_buffer_max_size';

/*如果要在这张表中插入一个新记录(4,400)的话，InnoDB的处理流程是怎样的。
第一种情况是，这个记录要更新的目标页在内存中。这时，InnoDB的处理流程如下：
    对于唯一索引来说，找到3和5之间的位置，判断到没有冲突，插入这个值，语句执行结束；
    对于普通索引来说，找到3和5之间的位置，插入这个值，语句执行结束。
    这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的CPU时间。

第二种情况是，这个记录要更新的目标页不在内存中。这时，InnoDB的处理流程如下：
    对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；
    对于普通索引来说，则是将更新记录在change buffer，语句执行就结束了。
    将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一。
      change buffer因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。

某个业务的库内存命中率突然从99%降低到了75%，整个系统处于阻塞状态，更新语句全部堵住。
而探究其原因后，我发现这个业务有大量插入数据的操作，而他在前一天把其中的某个普通索引改成了唯一索引。

 */

/*change buffer的使用场景
  对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。

  */

/*
  WAL 提升性能的核心机制，也的确是尽量减少随机读写
 insert into t(id,k) values(id1,k1),(id2,k2);
  Page 1在内存中，直接更新内存；
  Page 2没有在内存中，就在内存的change buffer区域，记录下“我要往Page 2插入一行”这个信息
  将上述两个动作记入redo log中（图中3和4）。
  select * from t where k in (k1, k2)
  如果读语句发生在更新语句后不久，内存中的数据都还在
  读Page 1的时候，直接从内存返回。
  要读Page 2的时候，需要把Page 2从磁盘读入内存中，然后应用change buffer里面的操作日志，生成一个正确的版本并返回结果。
  redo log 主要节省的是随机写磁盘的IO消耗（转成顺序写），而change buffer主要节省的则是随机读磁盘的IO消耗。
 */

/*
    change buffer一开始是写内存的，那么如果这个时候机器掉电重启，会不会导致change buffer丢失呢？
    change buffer丢失可不是小事儿，再从磁盘读入数据可就没有了merge过程，就等于是数据丢失了。会不会出现这种情况呢？
不会丢失，虽然是只更新内存，但是在事务提交的时候，change buffer的操作也记录到redo log里了，所以崩溃恢复的时候，change buffer也能找回来。

merge的执行流程是这样的：从磁盘读入数据页到内存（老版本的数据页）；
从change buffer里找出这个数据页的change buffer 记录(可能有多个），依次应用，得到新版数据页；
写redo log。这个redo log包含了数据的变更和change buffer的变更。
到这里merge过程就结束了。这时候，数据页和内存中change buffer对应的磁盘位置都还没有修改，属于脏页，之后各自刷回自己的物理数据。

 */