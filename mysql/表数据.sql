/*
一个InnoDB表包含两部分，即：表结构定义和数据。
在MySQL 8.0版本以前，表结构是存在以.frm为后缀的文件里。而MySQL 8.0版本，则已经允许把表结构定义放在系统数据表中了。

表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数innodb_file_per_table控制的：
    设置为OFF表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；
    设置为ON表示的是，每个InnoDB表数据存储在一个以 .ibd为后缀的文件中。

将innodb_file_per_table设置为ON，是推荐做法，因为一个表单独存储为一个文件更容易管理，而且在删除表的时候，通过drop table命令，
系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。
 */
select @@innodb_file_per_table;

/*InnoDB的数据是按页存储的，那么如果我们删掉了一个数据页上的所有记录，会怎么样？
    答案是，如果将数据页page A上的所有记录删除以后，page A会被标记为可复用。整个数据页就可以被复用了。
    但是，数据页的复用跟记录的复用是不同的。记录的复用，只限于符合范围条件的数据。

  如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用。

  如果我们用delete命令把整个表的数据删除呢？结果就是，所有的数据页都会被标记为可复用。但是磁盘上，文件不会变小。
  delete命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。也就是说，通过delete命令是不能回收表空间的。
  这些可以复用，而没有被使用的空间，看起来就像是“空洞”。

  实际上，不止是删除数据会造成空洞，插入数据也会。如果数据是按照索引递增顺序插入的，那么索引是紧凑的。
  但如果数据是随机插入的，就可能造成索引的数据页分裂。页分裂完成后，page A的末尾就留下了空洞

  更新索引上的值，可以理解为删除一个旧的值，再插入一个新值。这也是会造成空洞的。
 */

#重建表:主键索引更紧凑，数据页的利用率也更高。
alter table t engine=InnoDB;
/*描述一下引入了Online DDL之后，重建表的流程：
    1.建立一个临时文件，扫描表A主键的所有数据页；
    2.用数据页中表A的记录生成B+树，存储到临时文件中；
    3.生成临时文件的过程中，将所有对A的操作记录在一个日志文件（row log）中，对应的是图中state2的状态；
    4.临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表A相同的数据文件，对应的就是图中state3的状态；
    5.用临时文件替换表A的数据文件。
  由于日志文件记录和重放操作这个功能的存在，这个方案在重建表的过程中，允许对表A做增删改操作。

  Alter语句在启动的时候需要获取MDL写锁，但是这个写锁在真正拷贝数据之前就退化成读锁了。
  MDL读锁不会阻塞增删改操作。那为什么不干脆直接解锁呢？为了保护自己，禁止其他线程对这个表同时做DDL。

  而对于一个大表来说，Online DDL最耗时的过程就是拷贝数据到临时表的过程，这个步骤的执行期间可以接受增删改操作。
  所以，相对于整个DDL过程来说，锁的时间非常短。对业务来说，就可以认为是Online的。
  对于很大的表来说，这个操作是很消耗IO和CPU资源的。
 */

 /*
 Online：把表A中的数据导出来的存放位置叫作tmp_table。这是一个临时表，是在server层创建的。
 inplace：根据表A重建出来的数据是放在“tmp_file”里的，这个临时文件是InnoDB在内部创建出来的。整个DDL过程都在InnoDB内部完成。
 对于server层来说，没有把数据挪动到临时表，是一个“原地”操作，这就是“inplace”名称的来源。

 如果你有一个1TB的表，现在磁盘间是1.2TB，能不能做一个inplace的DDL呢？
 答案是不能。因为，tmp_file也是要占用临时空间的。
  */
alter table t engine=InnoDB;
#其实隐含的意思是：
alter table t engine=innodb,ALGORITHM=inplace;

#跟inplace对应的就是拷贝表的方式了，用法是：
alter table t engine=innodb,ALGORITHM=copy;
#当你使用ALGORITHM=copy的时候，表示的是强制拷贝表，对应的流程就是图3的操作过程。

#如果我要给InnoDB表的一个字段加全文索引，写法是：alter table t add FULLTEXT(field_name);
# #这个过程是inplace的，但会阻塞增删改操作，是非Online的。

/*
 DDL过程如果是Online的，就一定是inplace的；
反过来未必，inplace的DDL，有可能不是Online的。截止到MySQL 8.0，添加全文索引（FULLTEXT index）和空间索引(SPATIAL index)就属于这种情况。

 */

alter table t engine = InnoDB;#（也就是recreate）默认的就是上面图4的流程了；
analyze table t ;#其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了MDL读锁；
optimize table t ;#等于recreate+analyze。

/*
 假设现在有人碰到了一个“想要收缩表空间，结果适得其反”的情况，看上去是这样的：
    一个表t文件大小为1TB；对这个表执行 alter table t engine=InnoDB；
    发现执行完成后，空间不仅没变小，还稍微大了一点儿，比如变成了1.01TB。

    这个表，本身就已经没有空洞的了，比如说刚刚做过一次重建表操作。
    在DDL期间，如果刚好有外部的DML在执行，这期间可能会引入一些新的空洞。
    在重建表的时候，InnoDB不会把整张表占满，每个页留了1/16给后续的更新用。也就是说，其实重建表之后不是“最”紧凑的。

 将表t重建一次；插入一部分数据，但是插入的这些数据，用掉了一部分的预留空间；
 这种情况下，再重建一次表t，就可能会出现问题中的现象。
 */